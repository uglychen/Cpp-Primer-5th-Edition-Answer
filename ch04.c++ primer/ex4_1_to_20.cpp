/*

4.1答：105

4.2答：（a）*（vec.begin（））；（b）*（vec.begin（））+1

4.3答：这可以接受。因为，操作数的求解次序通常对结果没什么影响。只有当二元操作符的两个操作数涉及同一对象，
并改变该对象的值时，操作数的求解次序才会影响计算结果；后一种情况只会在部分（甚至是少数）程序中出现。
在实际使用中，这种“潜在的缺陷”可以通过程序员的努力得到弥补，但“实现效率”的提高却能使所有使用该编译器的程序受益，因此利大于弊。

4.4答：(((12 / 3) * 4) + (5 15))+ ((24 % 4) /2)；

4.5答：-86、-18、0、-2；

4.6答：ival%2==0；判断结果是否为true，若为true则为偶数，否则为奇数；

4.7答：2^16+1；10000*10000；3276*3276；

4.8答：采用短路求值的策略，逻辑与、逻辑或这两种运算符都是先求左值，当且仅当左侧运算对象为
真时才对右侧运算对象求值。相等性运算符（==）优先级别高于其他逻辑运算符。

4.9答：当指针cp不为空指针且cp指向的字符不为空字符就能输出字符；

4.10答：a>b&&b>c&&c>d;

4.11答: i != (j<k)；

4.13答：（a）d=i=3；（b）i=3，d=3.5；

4.14答：if（42=i）这个非法，42=i是个赋值表达式，42是个字面值不能作为作为左操作数；if（i=42）这表达式合法， i=42的结果永远为真。

4.15答：pi是一个指针变量，得到0值，表示的是地址，不能赋值给int型ival，类型不一样时可
以执行隐式转换，但是这里不能自动把指针类型转换成int型，可以把表达式修改成，dval=ival=0；pi=0；

4.16答：（a）该表达式的意图是getPtr()赋值给p，然后判断p是否为0，=优先级比!=优先级低，先把getptr()
是否为0的结果赋值给p，p得到的结果不是true就是false。应该修改成为if( (p=getPtr()) ！= 0);（b）该
表达是想要判断i是否等于1024，而表达式的意思是把1024赋值给i，然后判断i=1024整个是否为真。应该修改成if(i==1024);

4.17答：前置版本是首先将运算对象加1（或减1），然后将改变后的对象作为求值结果，后置版本也会将对
	象加1（或减1），但是求值结果是运算对象改变之前的那个值得副本。

4.18答：写成前置的形式是：*++pbeg；vector中的第一个元素（对象）没有输出，而且还试图解引用尾后迭代器，这是未定义的行为，将引发错误。

4.19答：（a）ptr指针不为空指针且*ptr++为真时整个表达结果才为真。（b）非法，改成ival&&ival++；（c）非法，vec[ival++]<=vec[ival--];

4.20答：（a）合法；（b）合法；（c）非法，指针没有empty()的成员，改成(*iter).empty()；（d）合法；（e）合法；（f）合法；


*/